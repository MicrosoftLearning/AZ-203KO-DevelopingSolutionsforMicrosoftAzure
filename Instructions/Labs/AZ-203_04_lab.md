---
랩:
    제목: '랩: 서비스 전반에서 리소스 비밀에 안전하게 액세스합니다'
    모듈: ‘모듈 4: Azure 보안 구현'
---

# 랩: 서비스 전반에서 리소스 비밀에 안전하게 액세스합니다.
# 학생 랩 매뉴얼

## 랩 시나리오

회사에서 B2B(비즈니스 간) 계약을 다른 지역 비즈니스와 계약을 맺고 야간에 삭제된 파일을 구문 분석해야 합니다. 일을 간단하게 하기 위해 두 번째 회사는 매일 밤 마이크로소프트 Azure 저장소 블랍으로 파일을 삭제 하기로 결정 했습니다. 이제 파일을 인터넷에 노출하지 않고 내부 시스템에서 블랍에 액세스하는 데 사용할 수 있는 보안 URL 을 생성하고 파일에 안전하게 액세스하는 방법을 고안해야 합니다. Microsoft Azure Key Vault 를 사용하여 저장소 계정 및 Azure Functions 에 대한 자격 증명을 저장하여 일반 텍스트로 자격 증명을 못 저장하거나 파일을 인터넷에 노출해서 파일에 안전하게 액세스하기 위해 필요한 코드를 작성하기로 결정했습니다.

## 목표

이 과정을 완료하면 다음과 같은 역량을 갖추게 됩니다.

  - Azure 키 볼트 만들고 및 키 볼트에 비밀을 저장합니다.

  - Azure 어플 서비스 인스턴스에 대해할당된 서버가 관리되는 ID를 만듭니다.

  - Azure 액티브 디렉터리 ID 또는 응용 프로그램에 대한 Azure 키 볼트 액세스 정책을 만듭니다.

  - Azure Storage .NET 소프트웨어 개발 키트(SDK)를 사용하여 블랍을 안전하게 다운로드합니다.

  - Azure Storage .NET SDK 를 사용하여 블랍에 대한 SAS(공유 액세스 서명) 토큰을 생성합니다.

## 랩 설정

  - **예상 시간**: 60 분

## 지침

### 시작하기 전에

#### 랩 가상 기계에 로그인

  - 다음 자격 증명을 사용하여 **Windows 10** 가상 기계에 로그인되어 있는지 확인합니다.
    
      - **사용자 이름**: 관리자
    
      - **비밀번호**: Pa55w.rd

#### 설치된 응용 프로그램 검토

  - **Windows 10** 바탕 하단에 있는 작업 표시줄을 관찰합니다. 작업 표시줄에는 이 랩에서 사용할 응용 프로그램에 대한 아이콘이 포함되어 있습니다.
    
      - 마이크로소프트 에지
    
      - 파일 탐색기

#### 랩 파일 다운로드

1.  작업 표시줄에서 **Windows PowerShell** 아이콘을 선택합니다.

2.  PowerShell 명령 프롬프트에서 현재 작업 디렉토리를 **Allfiles(F):\\** 경로로 변경합니다.

    ```
    cd F:
    ```

3.  명령 프롬프트 내에서 다음 명령을 입력하고 Enter 를 누르며 GitHub 에서 호스팅되는 **microsoftlearning/AZ-203-DevelopingSolutionsForAzure** 프로젝트를 **랩파일** 디렉토리로 복제합니다.

    ```
    git clone --depth 1 --no-checkout https://github.com/microsoftlearning/AZ-203-DevelopingSolutionsForMicrosoftAzure .
    ```

4.  명령 프롬프트 내에서 다음 명령을 입력하고 **AZ-203.02** 랩을 완료하기 위해 필요한 랩 파일을 체크아웃하여 **Enter** 를 누릅니다.

    ```
    git checkout master -- Allfiles/*
    ```

5.  현재 실행 중인 **Windows PowerShell** 명령 프롬프트 응용 프로그램을 닫습니다.

### 연습 1: Azure 리소스 만들기

#### 작업 1: Azure 포털 열기

1.  **Azure 포털** 에 로그인합니다(http://portal.azure.com>).

2.  Azure 포털에 처음 로그인하는 경우 포털 둘러보기를 제공하는 대화 박스가 표시됩니다. 투어를 건너뛰려면 **시작하기** 를 클릭합니다.

#### 작업 2: Azure 저장소 계정 만들기

1.  다음 세부 정보에 따라서 새 **저장소 계정** 을 만들겁니다:
    
      - **새** **리소스** **그룹**: 보안 기능
    
      - **이름**: securestor \[소문자로 이름\]
    
      - **위치**: 미국 동부
    
      - **성능**: 표준
    
      - **계정** **종류**: 스토리지 V2 (일반용 v2)
    
      - **복제**: 로컬 중복 스토리지(LRS)
    
      - **액세스** **계층**: 핫

> > 참고: 랩을 진행하기 전에 Azure 에서 저장소 계정 만들기가 완료될 때까지 기다립니다. 계정이 생성되면 알림을 받게 됩니다.

2.  새로 만든 **저장소 계정** 인스턴스의 **액세스 키** 블레이드를 엽니다.

3.  **연결 문자열** 필드에 값을 기록합니다. 이 랩의 나중에 이 값을 사용합니다.

#### 작업 3: Azure 키 볼트 만들기

  - 다음 세부 정보에 따라서 새 **키 볼트** 를 만들겁니다:
    
      - **이름**: securevault\[소문자로 이름\]
    
      - **기존** **리소스** **그룹:** 보안 기능
    
      - **위치**: 미국 동부

> > 참고: 랩을 진행하기 전에 Azure 에서 키 볼트 만들기가 완료될 때까지 기다립니다. 볼트가 생성되면 알림을 받게 됩니다.

#### 작업 4: Azure 함수 어플 만들기

  - 다음 세부 정보에 따라서 새 **함수 어플** 을 만들겁니다:
    
      - **어플 이름**: securefunc\[소문자로 이름\]
    
      - **기존** **리소스** **그룹:** 보안 기능
    
      - **OS**: Windows
    
      - **호스팅 계획**: 소비 계획
    
      - **위치**: 미국 동부
    
      - **런타임 스택**: .NET
    
      - **스토리지**: securestor\ [소문자로 이름[여기\]

> > 참고: 랩을 진행하기 전에 Azure 가 함수 어플 만들기를 완료할 때까지 기다립니다. 어플을 만들 때 알림을 받게 됩니다.

#### 검토

이 연습에서는 이 랩에 사용할 모든 리소스를 만들었습니다.

### 연습 2: 비밀 및 ID 구성 

#### 작업 1: 할당된 시스템 관리형 서비스 ID 구성

1.  이전에 랩에서 만든 **securefunc\*** 함수 어플에 액세스합니다.

2.  **플랫폼 피처** 탭에 있는 **ID** 설정으로 이동합니다.

3.  **할당된 시스템** 에서 관리 ID 를 활성화하고 변경 내용을 저장합니다.

#### 작업 2: 키 볼트 비밀 만들기

1.  이전에 랩에서 만든 **securevault\*** 키 볼트에 액세스합니다.

2.  **설정** 섹션에 있는 **비밀** 링크로 이동합니다.

3.  다음 설정을 사용하여 새 **비밀** 을 만듭니다.
    
      - **이름**: 스토리지 자격 증명
    
      - **값**: \<Storage Connection String\>
    
      - **사용 가능**: Yes

> > 참고: 비밀의 **값** 을 위하여 이전에 랩에서 기록한 저장소 계정 **연결 문자열** 을 사용합니다.

4.  비밀을 클릭하여 최신 버전의 메타데이터를 봅니다.

5.  나중에 랩에서 이 값을 사용하기 때문에 **비밀 식별자** 필드의 값을 기록합니다.

#### 작업 3: 키 볼트 액세스 정책 구성

1.  이전에 랩에서 만든 **securevault\*** 키 볼트에 액세스합니다.

2.  **설정** 섹션에 있는 **액세스 정책** 링크로 이동합니다.

3.  다음 설정을 사용하여 새 **액세스 정책** 을 만듭니다.
    
      - **원칙** : securefunc\[소문자로 이름\]
    
      - **키 사용 권한**: 없음
    
      - **비밀 권한**: GET
    
      - **인증서 권한**: 없음
    
      - **승인된 응용 프로그램**: 없음

4.  변경 내용을 **액세스 정책** 목록에 **저장** 합니다.

#### 검토

이 연습에서는 함수 어플에 대해 할당된 서버에서 관리되는 서비스 ID 를 만든 다음 해당 ID 에 Key Vault 에서 비밀값을 얻을 수 있는 적절한 권한을 부여했습니다. 마지막으로 함수 어플 내에서 사용할 비밀을 만들었습니다.

### 연습 3: 함수 어플 코드 작성 

#### 작업 1: 키 볼트 파생 응용 프로그램 설정 만들기 

1.  이전에 랩에서 만든**securefunc\*** 함수 어플에 액세스합니다.

2.  **플랫폼 피처** 탭에 있는 **응용 프로그램 설정** 으로 이동합니다.

3.  다음 세부 정보를 사용하여 새 **응용 프로그램 설정** 을 만듭니다.
    
      - **이름**: 스토리지연결스트링
    
      - **값**: @Microsoft.KeyVault(SecretUri=\<Secret Identifier\>)
    
      - **슬롯 설정**: 선택하지 않음

> > 참고: 위의 구문을 사용하여 **비밀 식별자** 에 대한 참조를 작성해야 합니다. 예를 들어 비밀 식별자가 ** https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf** 의 경우 **@Microsoft.KeyVault(SecretUri= https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf)** 값이 됩니다.

4.  변경 내용을 응용 프로그램 설정에 **저장** 합니다.

#### 작업 2: HTTP 트리거 함수 만들기

1.  이전에 랩에서 만든 **securefunc\*** 함수 어플에 액세스합니다.

2.  다음 설정을 사용하여 새 **함수** 를 만듭니다.
    
      - **개발 환경**: 포털에서
    
      - **템플릿**: HTTP 트리거
    
      - **이름**: 파일 파서
    
      - **권한 부여 수준**: 익명

3.  함수 편집기에서 예제 함수 스크립트를 다음 자리 표시자 C\# 코드로 바꿉니다.

<!-- end list -->

    using System.Net;
    using Microsoft.AspNetCore.Mvc;
    
    public static async Task<IActionResult> Run(HttpRequest req)
    {
        return new OkObjectResult("Test Successful"); 
    }

4.  **저장 및 실행** 을 클릭하여 함수의 테스트 실행을 수행합니다. 실행의 출력은 **테스트 성공** 입니다.

#### 작업 3: 응용 프로그램 설정 테스트

1.  **Run** 메서드 내의 모든 기존 코드를 삭제합니다.

2.  **Environment.GetEnvironmentVariable** 메서드를 사용하여 **StorageConnectionString** 응용 프로그램 설정의 값을 얻읍니다.

<!-- end list -->

    string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");

3.  **OkObjectResult** 클래스 생성자를 사용하여 **연결 문자열** 변수의 값을 반환합니다.

<!-- end list -->

    return new OkObjectResult(connectionString);

4.  **저장 및 실행** 을 클릭하여 함수의 테스트 실행을 수행합니다. 실행의 출력은 **Azure Key Vault** 에 저장된 **저장소 계정** 연결 문자열이어 야합니다.

#### 검토

이 연습에서는 서비스 ID 를 사용하여 **Azure Key Vault** 에 저장된 비밀의 값을 읽고 **Azure Function** 의 결과로 해당 값을 반환합니다.

### 연습 4: 저장소 계정 블랍을 액세스

#### 작업 1: 샘플 저장소 블랍 업로드

1.  이전에 랩에선 만든 **securestor\*** 저장소 계정에 액세스합니다.

2.  **블랍** 서비스 섹션에 있는 **Blob** 링크로 이동합니다.

3.  다음 설정을 사용하여 새 **컨테이너** 를 만듭니다.
    
      - **이름**: 드롭
    
      - **공용 액세스 수준**: Blob(블랍에 대한 익명 읽기 액세스만)

4.  새 **드롭** 컨테이너로 이동합니다.

5.  **업로드를** 클릭하여 랩 머신에 **Allfiles(F):\\Labfiles\\04\\Starter** 파일에 있는 **records.json** 파일을 업로드합니다.

> > 참고**:** **파일이 이미 있는 경우 덮어쓰기** 옵션을 사용하도록 설정하는 것이 좋습니다.

6.  블랍 목록의 블랍 들어감을 클릭하여 **records.json** 블랍의 메타데이터를 봅니다.

7.  새 브라우저 탭을 사용하여 블랍의 **URL** 로 이동하여 블랍의 내용을 봅니다.

8.  **공용 액세스 수준** 을 **Private(익명 액세스 없음)** 으로 변경하여 컨테이너의 **액세스 수준** 을 업데이트합니다.

9.  새 브라우저 창 또는 탭을 사용하여 블랍의 **URL** 로 이동하여 Blob의 내용을 봅니다. 이제 리소스를 찾을 수 없다는 오류 메시지가 표시됩니다.

> > 참고: 오류 메시지가 표시되지 않으면 브라우저에서 파일을 캐치했을 수 있습니다. **Ctrl+F5** 를 사용하여 오류 메시지가 표시될 때까지 페이지를 새로 고칩니다.

#### 작업 2: 저장소 계정 SDK 구성

1.  이전에 랩에서 만든 **securefunc\*** 함수 어플에 액세스합니다.

2.  **FileParser** 함수에 대한 편집기 열기를 엽니다.

3.  **파일 보기** 탭을 사용하여 랩 기계에 **Allfiles (F):\\Labfiles\\04\\Starter** 폴더에 있는 **function.proj** 파일을 업로드합니다.

4.  **파일 보기** 탭에서 파일을 클릭하여 **function.proj** 파일의 내용을 봅니다.

5.  **파일 보기** 탭에서 **run.csx** 파일을 클릭하여 **FileParser** 함수의 편집기로 돌아갑니다.

6.  **Microsoft.WindowsAzure.Storage** 및 **Microsoft.WindowsAzure.Storage.Blob** 네임스페이스를 위하여 블록 두 개를 **사용** 하여 추가합니다.

7.  **Run** 메서드 내의 모든 기존 코드를 삭제합니다.

#### 작업 3: 저장소 계정 코드 작성

1.  **Environment.GetEnvironmentVariable** 메서드를 사용하여 **StorageConnectionString** 응용 프로그램 설정의 값을 얻읍니다.

<!-- end list -->

    string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");

2.  **CloudStorageAccount.Parse** 정적 메서드를 사용하여 **CloudStorageAccount** 클래스의 새 인스턴스를 만들고 *연결String* 변수를 전달합니다.

<!-- end list -->

    CloudStorageAccount account = CloudStorageAccount.Parse(connectionString);

3.  **CloudStorageAccount.CreateCloudBlobClient** 메서드를 사용하여 저장소 계정의 블랍에 대한 액세스 권한을 부여하는 **CloudBlobClient** 클래스의 새 인스턴스를 만듭니다.

<!-- end list -->

    CloudBlobClient blobClient = account.CreateCloudBlobClient();

4.  **drop** 컨테이너 이름을 전달하는 동안 **CloudBlobClient.GetContainerReference** 메서드를 사용하여 이전에 랩에서 만든 컨테이너를 참조하는 **CloudBlobContainer** 클래스의 새 인스턴스를 만듭니다.

<!-- end list -->

    CloudBlobContainer container = blobClient.GetContainerReference("drop");

5.  **records.json** 블랍 이름을 전달하는 동안 **CloudBlobContainer.GetBlockBlobReference** 메서드를 사용하여 이전에 랩에서 업로드한 블랍을 참조하는 **CloudBlockBlob** 클래스의 새 인스턴스를 만듭니다.

<!-- end list -->

    CloudBlockBlob blob = container.GetBlockBlobReference("records.json");

#### 

#### 작업 4: 블랍 다운로드

1.  **CloudBlockBlob.DownloadTextAsync** 메서드를 사용하여 참조된 블랍의 내용을 비동기적으로 다운로드하고 결과를 문자열 변수라는 *콘텐츠* 에 저장합니다.

<!-- end list -->

    string content = await blob.DownloadTextAsync();

2.  **OkObjectResult** 클래스 생성자 사용하여 *콘텐츠* 변수의 값을 반환합니다.

<!-- end list -->

    return new OkObjectResult(content);

3.  **저장 및 실행** 을 클릭하여 함수의 테스트 실행을 수행합니다. 실행의 출력은 저장소 계정에 저장된 **$/drop/records.json** 블랍의 내용이어 야합니다.

#### 작업 5: 공유 액세스 서명(SAS) 생성

1.  기존 코드 줄을 **삭제** 합니다.

<!-- end list -->

    string content = await blob.DownloadTextAsync();
    return new OkObjectResult(content);

2.  다음 설정을 사용하여 **SharedAccessPolicy** 클래스의 새 인스턴스를 만듭니다.
    
      - **허가**: 읽기:
    
      - **서비스 범위**: Blob
    
      - **리소스 유형**: 개체
    
      - **만료 시간**: 2 시간
    
      - **프로토콜:** HTTPS 전용

<!-- end list -->

    SharedAccessAccountPolicy policy = new SharedAccessAccountPolicy()
    {
        Permissions = SharedAccessAccountPermissions.Read,
        Services = SharedAccessAccountServices.Blob,
        ResourceTypes = SharedAccessAccountResourceTypes.Object,
        SharedAccessExpiryTime = DateTime.UtcNow.AddHours(2),
        Protocols = SharedAccessProtocol.HttpsOnly
    };
    
3.  다음 코드 줄을 추가하여 CloudStorageAccount.GetSharedAcessSignature 메서드를 사용하여 제공된 정책을 사용하여 새 SAS(공유 액세스 서명) 토큰을 생성한 다음 결과를 sasToken이라는 문자열 변수에 저장합니다.

<!-- end list -->

    string sasToken = account.GetSharedAccessSignature(policy);

4.  **CloudBlockBlob.Uri** 속성 및 *sasToken* 문자열 변수의 값을 연결하고 *secureBlobUrl* 라는 새 변수에 결과 저장합니다.

<!-- end list -->

    string secureBlobUrl = $"{blob.Uri}{sasToken}";

5.  **OkObjectResult** 클래스 생성자를 사용하여 *secureBlobUrl* 변수의 값을 반환합니다.

<!-- end list -->

    return new OkObjectResult(secureBlobUrl);

6.  **저장 및 실행** 단추를 사용하여 함수의 테스트 실행을 수행합니다. 실행의 출력은 보안 블랍에 액세스를 사용하여 유일한 **Secure Url** 이어야 합니다. 이랩에 다음 단계에서 사용해야 하므로 이 **URL** 을 기록합니다.

7.  새 브라우저 창 또는 탭을 사용하여 블랍의 **보안 URL** 로 이동하여 블랍의 내용을 봅니다.

#### 복습

이 연습에서는 C\# 코드를 사용하여 저장소 계정에 안전하게 액세스하고 Blob 의 내용을 다운로드한 다음 다른 클라이언트에서 블랍에 안전하게 액세스를 사용할 수 있는 SAS 토큰을 생성했습니다.

### 연습 5: 구독 정리 

#### 작업 1: Azure 클라우드 셸 열기 및 리소스 그룹 나열

1.  포털 상단에서 **클라우드 셸** 아이콘을 클릭하여 새 셸 인스턴스를 엽니다.

2.  포털 하단에 **클라우드 셸** 명령 프롬프트에서 다음 명령을 입력하고 Enter 를 눌러 구독의 모든 리소스 그룹을 나열합니다.

<!-- end list -->

    az group list

3.  다음 명령을 입력하고 Enter 를 눌러 리소스 그룹을 삭제할 수 있는 명령 목록을 봅니다.

<!-- end list -->

    az group delete --help

#### 작업 2: 리소스 그룹 삭제

1.  다음 명령을 입력하고 Enter 를 눌러 **SecureFunction** 리소스 그룹을 삭제합니다.

<!-- end list -->

    az group delete --name SecureFunction --no-wait --yes

2.  포털 하단의 **클라우드 셸** 페인을 닫습니다.

#### 작업 3: 액티브 응용 프로그램 닫기

> 현재 실행 중인 **Microsoft Edge** 응용 프로그램을 닫습니다.

#### 검토

이 연습에서는 이 랩에 사용된 **리소스 그룹** 을 제거하여 구독을 정리했습니다.
