---
lab:
    title: '랩: 수개 국어 데이터 솔루션 생성'
    module: '모듈 3: Azure 스토리지용 개발'
---

# 랩: 수개 국어 데이터 솔루션 생성
# 학생 랩 매뉴얼

## 랩 시나리오

Microsoft Azure 에서 두 개 이상의 데이터 서비스를 사용하도록 회사의 기존 이벤트 등록 시스템을 업데이트하는 작업이 할당되었습니다. 회사의 목표는 각 응용 프로그램 구성 요소에 가장 적합한 데이터 서비스를 활용하는 것입니다. 철저한 조사를 수행한 후 Azure Storage 에 이벤트 등록 시트, Azure SQL Database 의 이벤트 메타데이터 및 Azure Cosmos DB의 이벤트 등록을 저장하기로 결정합니다. 기존 응용 프로그램 코드를 가져 와서 Azure 에서 호스팅되는 이러한 데이터 서비스에 연결하고 사용하기 위해 다시 작성합니다.

## 목표

이 랩을 완료하면 다음과 같은 역량을 갖추게 됩니다.

  - 엔터티 프레임워크를 사용하여 Azure SQL 데이터베이스에 연결하려면 C\# 코드를 작성합니다.

  - Azure Cosmos DB 클라이언트 라이브러리를 사용하여 Azure Cosmos DB 에 연결하는 C\# 코드를 작성합니다.

  - Azure Functions 바인딩을 사용하여 Azure 저장소에 연결하는 C\# 코드를 작성합니다.

## 랩 설정

  - **예상 시간**: 60 분

## 지침

### 시작하기 전에

#### 랩 가상 기계에 로그인

  - 다음 자격 증명을 사용하여 **Windows 10** 가상 기계에 로그인되어 있는지 확인합니다.
    
    1.  **사용자 이름**: 관리자
    
    2.  **비밀번호**: Pa55w.rd

#### 설치된 응용 프로그램 검토

  - **Windows 10** 바탕 하단에 있는 작업 표시줄을 관찰합니다. 작업 표시줄에는 이 랩에서 사용할 응용 프로그램에 대한 아이콘이 포함되어 있습니다.
    
      - 마이크로소프트 에지
    
      - 파일 탐색기 
    
      - Visual Studio Code

#### 랩 파일 다운로드

1.  작업 표시줄에서 **Windows PowerShell** 아이콘을 선택합니다.

2.  PowerShell 명령 프롬프트에서 현재 작업 디렉토리를 **Allfiles(F):\\** 경로로 변경합니다.

    ```
    cd F:
    ```

3.  명령 프롬프트 내에서 다음 명령을 입력하고 Enter 를 누르며 GitHub 에서 호스팅되는 **microsoftlearning/AZ-203-DevelopingSolutionsForAzure** 프로젝트를 **랩파일** 디렉토리로 복제합니다.

    ```
    git clone --depth 1 --no-checkout https://github.com/microsoftlearning/AZ-203-DevelopingSolutionsForMicrosoftAzure .
    ```

4.  명령 프롬프트 내에서 다음 명령을 입력하고 **Enter** 를 눌러 **AZ-203.02** 랩을 완료할 때 필요한 랩 파일을 체크 아웃합니다.

    ```
    git checkout master -- Allfiles/*
    ```

5.  현재 실행 중인 **Windows PowerShell** 명령 프롬프트 응용 프로그램을 닫습니다.

### 연습 1: Azure 에서 데이터베이스 리소스 만들기

#### 작업 1: Azure 포털 열기

1.  **Azure 포털** 에 로그인합니다(http://portal.azure.com>).

2.  Azure 포털에 처음 로그인하는 경우 포털 둘러보기를 제공하는 대화 박스가 표시됩니다. **시작 하기** 버튼를 선택하여 투어를 건너뜁니다.

#### 작업 2: SQL 데이터베이스 리소스 만들기

1.  다음 세부 정보에 따라서 새 **SQL 서버** 를 만들겁니다.
    
      - **서버** **이름**:polysqlsrvr\[소문자로 이름\]
    
      - **새 리소스** **그룹**: 수개 국어 데이터
    
      - **서버 관리자** **로그인**: 테스트유저
    
      - **비밀번호**: TestPa$$w0rd
    
      - **위치**: 미국 동부
    
    <!-- end list -->
    
      - **Azure 서비스가 액세스 서버에게 허용합니다**: Yes
    
      - **고급 데이터 보안**: 시기상조

> > 참고: 랩을 진행하기 전에 Azure 가 SQL 서버 인스턴스 만들기를 완료할 때까지 기다립니다. SQL 서버가 생성되면 알림을 받게 됩니다.

2.  다음 세부 정보에 따라서 새 해당하는 새 **SQL 데이터베이스** 를 저장합니다.
    
      - **데이터베이스 이름**: polysqldb
    
      - **기존 리소스** **그룹**: 수개 국어 데이터
    
      - **서버**: polysqlsrvr\[소문자로 이름\]
    
      - **SQL 탄성 풀**: No
    
      - **위치**: 미국 동부
    
      - **가격** **계층**: 기본
    
      - **계산 + 스토리지**: \[leave set to default value\]

> > 참고: 랩을 진행하기 전에 Azure 가 SQL 데이터베이스 인스턴스 만들기를 완료할 때까지 기다립니다. SQL 데이터베이스를 만들 때 알림을 받게 됩니다.

3.  새로 만든 **SQL 데이터베이스**의 **연결 문자열** 블레이드를 엽니다.

4.  **ADO.NET** 연결 문자열의 값을 기록합니다. {your\_username} 및 {your\_password}의 플레이스 홀더 값을 테스트유저 및 TestPa$$w0rd, ****로 바꿔야 합니다.

> > 참고: 예를 들어 복사된 연결 문자열이

    Server=tcp:polysqlsrvrstudent.database.windows.net,1433;Initial Catalog=polysqldb;Persist Security Info=False;User ID={your_username};Password={your_password};MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;,

> > 업데이트된 연결 문자열은

    Server=tcp:polysqlsrvrstudent.database.windows.net,1433;Initial Catalog=polysqldb;Persist Security Info=False;User ID=testuser;Password=TestPa$$w0rd;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;

5.  새로 만든 **SQL 서버** 의 **방화벽 및 가상 네트워크** 블레이드를 엽니다.

6.  허용되는 IP 주소 범위 목록에 가상 기계의 IP 주소를 추가합니다.

> > 참고: 방화벽이 서버에서 업데이트되는 경우 몇 분 정도 걸릴 수 있습니다.

#### 작업 3: Azure 코스모스 DB 계정 리소스 만들기

1.  다음과 같은 세부 정보를 사용하여 새 **Azure Cosmos DB** 인스턴스를 만듭니다.
    
      - **계정 이름**: polycosmos\[소문자로 이름\]
    
      - **기존 리소스** **그룹**: 수개 국어 데이터
    
      - **API**: 코어 (SQL)
    
      - **위치**: 미국 동부
    
      - **지리적 중복성**: 사용 금지
    
      - **다중 지역 쓰기**: 사용 금지

> 참고: 랩을 진행하기 전에 Azure 가 Azure Cosmos DB 계정 만들기를 완료할 때까지 기다립니다. Azure Cosmos DB 계정이 만들어지면 알림을 받게 됩니다.

2.  새로 만든 **Azure Cosmos DB** 인스턴스의 **키** 블레이드를 엽니다.

3.  **URI** 및 **기본 키** 의 값을 기록합니다. 이 랩의 나중에 이러한 값을 사용합니다.

#### 작업 4: Azure 저장소 계정 리소스 만들기

1.  다음 세부 정보에 따라서 새 **저장소 계정** 를 만들겁니다.
    
      - **저장소 계정 이름**: polystor\[소문자로 이름\]
    
      - **기존** **리소스** **그룹:** 수개 국어 데이터
    
      - **계정** **종류**: 스토리지 V2 (일반용 v2)
    
      - **위치**: 미국 동부
    
      - **복제**: 로컬 중복 스토리지(LRS)
    
      - **성능**: 표준
    
      - **액세스** **계층(기본값)**: 핫

> > 참고: 랩을 진행하기 전에 Azure 에서 저장소 계정 만들기가 완료될 때까지 기다립니다. 저장소 계정을 만들 때 알림을 받게 됩니다.

2.  새로 만든 **Azure** **Storage 계정** 인스턴스의 **액세스 키** 블레이드에 액세스합니다.

3.  **키** 중 하나를 기록하고 **연결 문자열** 필드에 값을 기록합니다. 이 랩에서 나중에 이 값을 사용합니다.

#### 검토

이 연습에서는 수개 국어 데이터 솔루션에 필요한 모든 Azure 리소스를 만들었습니다.

### 연습 2: ASP.NET 코어 웹 응용 프로그램 열기 및 구성

#### 작업 1: 웹 응용 프로그램 열기

  - Visual Studio Code 사용하여 다음에 있는 솔루션 폴더를 엽니다. **모든 파일 (F):\\Labfiles\\Starter**.

#### 작업 2: 응용 프로그램 설정 업데이트

1.  **Contoso.Events.Web** 프로젝트에 있는 **appsettings.json** 을 엽니다.

2.  다음 속성의 값을 찾아 업데이트합니다.
    
      - EndpointUrl: \[Azure 코스모스 DB URI\]
    
      - 권한 부여 키: \[Azure 코스모스 DB 키\]
    
      - 이벤트컨텍스트연결문자열: \[SQL 데이터베이스 연결 문자열\]

3.  **Appsettings.json** 파일을 저장합니다.

4.  **Contoso.Events.Worker** 프로젝트에 있는 **local.settings.json** 을 엽니다.

5.  다음 속성의 값을 찾아 업데이트합니다:
    
      - **AzureWebJobsStorage**: \[저장소 계정 연결 문자열\]
    
      - **AzureWebJobsDashboard**: \[저장소 계정 연결 문자열\]
    
      - **EventsContextConnectionString**: \[SQL 데이터베이스 연결 문자열\]
    
      - **CosmosEndpointUrl**: \[Azure 코스모스 DB URI\]
    
      - **CosmosAuthorizationKey**: \[Azure 코스모스 DB 키\]

6.  **Local.settings.json** 파일을 저장합니다.

#### 검토

이 연습에서는 Azure 의 리소스에 연결하도록 ASP.NET 코어 웹 응용 프로그램을 구성했습니다.

### 연습 3: Azure SQL 데이터베이스에 연결하는 엔터티 프레임워크 코드 작성

#### 작업 1: 데이터베이스 초기화 로직 구성

1.  비주얼 스튜디오 코드 창의 탐색기 ** ** 페인에서 **Contoso.Events.Data** 프로젝트를 확장합니다.

2.  탐색기 ** ** 페인에서 **ContextInitializer.cs** 두 번 클릭합니다.

3.  **InitializeAsync** 메서드를 찾습니다.

<!-- end list -->

    public async Task InitializeAsync(EventsContext eventsContext)

4.  **InitializeAsync** 메서드 내에서 다음 코드 줄을 추가하여 데이터베이스가 만들어지도록 합니다.

<!-- end list -->

    await eventsContext.Database.EnsureCreatedAsync();

5.  다음 코드 블록을 추가하여 데이터베이스에 이벤트가 없는 경우 **if** 블록 내에서만 코드를 실행하는 블록인 경우 조건부 코드를 만듭니다.

<!-- end list -->

    if (!await eventsContext.Events.AnyAsync())
    {
    }

6.  새로 생성된 **if** 블록 내에서 다음 코드 줄을 추가하여 **Event** 클래스의 새 인스턴스를 만듭니다.

<!-- end list -->

    Event eventItem = new Event();

7.  **If** 블록 내에서 다음 코드 블록을 추가하여 새 **Event** 클래스 인스턴스의 다양한 속성을 설정합니다.

<!-- end list -->

    eventItem.EventKey = "FY17SepGeneralConference";
    eventItem.StartTime = DateTime.Today;
    eventItem.EndTime = DateTime.Today.AddDays(3d);
    eventItem.Title = "FY17 September Technical Conference";
    eventItem.Description = "Sed in euismod mi.";
    eventItem.RegistrationCount = 1;

8.  **If** 블록 내에서 다음 코드 줄을 **DbSet\<Event\>** 형식의 속성을 가진 **Event** 가 새 **Events** 클래스 인스턴스에 추가합니다.

<!-- end list -->

    eventsContext.Events.Add(eventItem);

9.  **if** 블록 외부 및 다음을 수행하여 다음 코드 줄을 추가하여 변경 내용을 데이터베이스 컨텍스트에 저장합니다.

<!-- end list -->

    await eventsContext.SaveChangesAsync();

10. **InitializeAsync** 메서드는 이제 다음과 같이 보입니다.

<!-- end list -->

    public async Task InitializeAsync(EventsContext eventsContext)
    {
    await eventsContext.Database.EnsureCreatedAsync();
    
    (!await eventsContext.Events.AnyAsync())
    {
    Event eventItem = new Event();
    eventItem.EventKey = "FY17SepGeneralConference";
    eventItem.StartTime = DateTime.Today;
    eventItem.EndTime = DateTime.Today.AddDays(3d);
    eventItem.Title = "FY17 September Technical Conference";
    eventItem.Description = "Sed in euismod mi.";
    eventItem.RegistrationCount = 1;
    eventsContext.Events.Add(eventItem);
    }
    
    await eventsContext.SaveChangesAsync();
    }

11. **ContextInitializer.cs** 파일을 **저장합니다**.

#### 작업 2: 데이터베이스 초기화 업데이트

1.  비주얼 스튜디오 코드 창의 탐색기 페인에서 **Contoso.Events.Data** 프로젝트를 확장합니다.

2.  탐색기 ** ** 페인에서 **ContextInitializer.cs** 두 번 클릭합니다.

3.  **InitializeAsync** 메서드를 찾습니다.

<!-- end list -->

    public async Task InitializeAsync(EventsContext eventsContext)

4.  메서드를 다음 메서드 구현으로 바꿉니다.

<!-- end list -->

    public async Task InitializeAsync(EventsContext eventsContext)
    {
    await eventsContext.Database.EnsureCreatedAsync();
    
    if (!await eventsContext.Events.AnyAsync())
    {
    await eventsContext.Events.AddRangeAsync(
    new List<Event>() 
    {
    new Event { EventKey = "GeneralConferenceAlpha", StartTime = DateTime.Today, EndTime = DateTime.Today.AddDays(5d), Title = "First General Conference", Description = "Sed in euismod mi.", RegistrationCount = 15 },
    new Event { EventKey = "GeneralConferenceBravo", StartTime = DateTime.Today.AddDays(10d), EndTime = DateTime.Today.AddDays(15d), Title = "Second General Conference", Description = "Sed in euismod mi.", RegistrationCount = 20 },
    new Event { EventKey = "GeneralConferenceCharlie", StartTime = DateTime.Today.AddDays(20d), EndTime = DateTime.Today.AddDays(25d), Title = "Third General Conference", Description = "Sed in euismod mi.",  RegistrationCount = 5 },
    new Event { EventKey = "GeneralConferenceDelta", StartTime = DateTime.Today.AddDays(30d), EndTime = DateTime.Today.AddDays(35d), Title = "Fourth General Conference", Description = "Sed in euismod mi.", RegistrationCount = 25 },
    new Event { EventKey = "GeneralConferenceEcho", StartTime = DateTime.Today.AddDays(40d), EndTime = DateTime.Today.AddDays(45d), Title = "Fifth General Conference", Description = "Sed in euismod mi.", RegistrationCount = 10 },
    new Event { EventKey = "GeneralConferenceFoxtrot", StartTime = DateTime.Today.AddDays(50d), EndTime = DateTime.Today.AddDays(55d), Title = "Sixth General Conference", Description = "Sed in euismod mi.", RegistrationCount = 0 }
    }
    );
    
    await eventsContext.SaveChangesAsync();
    }
    }

5.  **ContextInitializer.cs** 파일을 **저장합니다**.

#### 작업 3: ASP.NET MVC 컨트롤러에 엔터티 프레임워크 쿼리 작성

1.  비주얼 스튜디오 코드 창의 탐색기 페인에서 **Contoso.Events.Web** 프로젝트를 확장합니다.

2.  탐색기 페인에서 **컨트롤러** 폴더를 확장합니다.

3.  탐색기 ** ** 페인에서 **HomeController.cs** 두 번 클릭합니다.

4.  **인덱스** 메서드를 찾습니다.

<!-- end list -->

    public IActionResult Index([FromServices] EventsContext eventsContext, [FromServices] IOptions<ApplicationSettings> appSettings)

5.  **인덱스** 메서드 내에서 다음 코드 줄을 찾습니다.

<!-- end list -->

    var upcomingEvents = Enumerable.Empty<Event>();

6.  **Events** 테이블을 쿼리하기 위해서 다음 코드 블록과 코드줄이 바꿔야 합니다. **StartTime** 속성으로 결과를 오더한 다음 응용 프로그램 설정에 따라 결과의 부분 집합을 검색(테이크)합니다.

<!-- end list -->

    var upcomingEvents = eventsContext.Events
    .Where(e => e.StartTime >= DateTime.Today)
    .OrderBy(e => e.StartTime)
    .Take(appSettings.Value.LatestEventCount);

7.  **HomeController.cs** 파일을 **저장합니다**.

8.  탐색기 페인에서 **EventsController.cs** 두 번 클릭합니다.

9.  **인덱스** 메서드를 찾습니다.

<!-- end list -->

    public IActionResult Index([FromServices] EventsContext eventsContext, [FromServices] IOptions<ApplicationSettings> appSettings, int? page)

10. **Index** 메서드 내에서 다음 코드 줄을 찾습니다.

<!-- end list -->

    var pagedEvents = Enumerable.Empty<Event>();

11. 코드 줄을 다음 코드 블록으로 바꿔서 **Events** 테이블을 쿼리하고 **스킵** 및 **테이크** 메서드를 사용하여 현재 페이지 번호를 기반으로 결과 페이지를 만듭니다.

<!-- end list -->

    int currentPage = page ?? 1.
    int totalRows = eventsContext.Events.Count();
    int pageSize = appSettings.Value.GridPageSize;
    var pagedEvents = eventsContext.Events
    .OrderByDescending(e => e.StartTime)
    .Skip(pageSize * (currentPage - 1))
    .Take(pageSize);

12. **Index** 메서드 내에서 다음 코드 블록을 찾습니다.

<!-- end list -->

    EventsGridViewModel viewModel = new EventsGridViewModel
    {
    CurrentPage = 0,
    PageSize = 0,
    TotalRows = 0,
    Events = pagedEvents
    };	

13. 코드 블록을 다음 코드 블록으로 바꿔서 **EventsGridViewModel** 클래스 인스턴스의 다양한 속성을 설정합니다.

<!-- end list -->

    EventsGridViewModel viewModel = new EventsGridViewModel
    {
    CurrentPage = currentPage,
    PageSize = pageSize,
    TotalRows = totalRows,
    Events = pagedEvents
    };

14. **세부** 메서드를 찾습니다.

<!-- end list -->

    public IActionResult Detail([FromServices] EventsContext eventsContext, string key)

15. **세부** 메서드 내에서 다음 코드 줄을 찾습니다.

<!-- end list -->

    var matchedEvent = default(Event);

16. 해당 코드 줄을 다음 코드 블록으로 바꿔 **Events** Table에서 **EventKey** 속성과 일치하는 싱글 레코드를 쿼리합니다.

<!-- end list -->

    var matchedEvent = eventsContext.Events
    .SingleOrDefault(e => e.EventKey == key);

17. **EventsController.cs** 파일을 **저장합니다**.

#### 검토

이 연습에서는 엔터티 프레임워크를 사용하여 Azure SQL 데이터베이스에 연결하는 C\# 코드를 작성했습니다.

### 연습 4: Azure 코스모스 DB 에 연결하는 Cosmos DB 클라이언트 라이브러리 코드 작성

#### 작업 1: Azure Functions 프로젝트에서 등록자 이름 검색

1.  **ProcessDocuments.cs** 파일을 열기.

2.  **ProcessDocuments.cs** 파일의 코드 편집기 탭에서 **ProcessDocuments** 클래스를 찾아 다음 클래스 구현으로 바꿉니다. 

<!-- end list -->

    public static class ProcessDocuments
    {
    private static ConnectionManager _connection = new ConnectionManager();
    private static RegistrationContext _registrationsContext = _connection.GetCosmosContext();
    
    [FunctionName("ProcessDocuments")]
    public static async Task Run([HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "")]HttpRequest request, TraceWriter log)
    {
    string message = request.Query["eventkey"];
    
    log.Info($"Request received to generate sign-in sheet for event: {message}");
    
    var registrants = await ProcessHttpRequestMessage(message);
    
    log.Info($"Registrants: {String.Join(", ", registrants)}");
    
    log.Info($"Request completed for event: {message}");
    }
    
    private static async Task<List<string>> ProcessHttpRequestMessage(string eventKey)
    {
    using (EventsContext eventsContext = _connection.GetSqlContext())
    {
    await eventsContext.Database.EnsureCreatedAsync();
    await _registrationsContext.ConfigureConnectionAsync();
    
    Event eventEntry = await eventsContext.Events.SingleOrDefaultAsync(e => e.EventKey == eventKey);
    
    List<string> registrants = await _registrationsContext.GetRegistrantsForEvent(eventKey);
    
    return registrants;
    }
    }
    }

3.  **ProcessDocuments.cs** 파일을 저장합니다.

#### 작업 2: 등록컨텍스트 클래스 구현

1.  **contoso.Events.Data** 프로젝트에 **RegistrationContext.cs** 를 열립니다.

2.  **RegisterContext** 파일에 대한 코드 편집기 탭에서 **RegisterContext** 클래스를 찾아 다음 클래스 구현으로 바꿉니다.

<!-- end list -->

    public class RegistrationContext
    {
    protected Database Database { get; set; }
    
    protected DocumentCollection Collection { get; set; }
    
    protected DocumentClient Client { get; set; }
    
    protected CosmosSettings CosmosSettings { get; set; }
    
    public RegistrationContext(IOptions<CosmosSettings> cosmosSettings)
    {
    CosmosSettings = cosmosSettings.Value;
    Client = new DocumentClient(new Uri(CosmosSettings.EndpointUrl), CosmosSettings.AuthorizationKey);
    }
    
    public async Task ConfigureConnectionAsync()
    {
    Database = await Client.CreateDatabaseIfNotExistsAsync(new Database { Id = CosmosSettings.DatabaseId });
    Collection = await Client.CreateDocumentCollectionIfNotExistsAsync(Database.SelfLink, new DocumentCollection { Id = CosmosSettings.CollectionId });
    }
    
    public async Task<int> GetRegistrantCountAsync()
    {
    FeedOptions options = new FeedOptions { EnableCrossPartitionQuery = true };
    IDocumentQuery<int> query = Client.CreateDocumentQuery<int>(Collection.SelfLink, "SELECT VALUE COUNT(1) FROM registrants", options).AsDocumentQuery();
    
    int count = 0;
    while (query.HasMoreResults)
    {
    FeedResponse<int> results = await query.ExecuteNextAsync<int>();
    count += results.Sum();
    }
    return count;
    }
    
    public async Task<List<string>> GetRegistrantsForEvent(string eventKey)
    {
    IDocumentQuery<GeneralRegistration> query = Client.CreateDocumentQuery<GeneralRegistration>(Collection.SelfLink).Where(r => r.EventKey == eventKey).AsDocumentQuery();
    
    List<string> registrants = new List<string>();
    while (query.HasMoreResults)
    {
    FeedResponse<GeneralRegistration> results = await query.ExecuteNextAsync<GeneralRegistration>();
    IEnumerable<string> resultNames = results.Select(r => $"{r.FirstName} {r.LastName}");
    registrants.AddRange(resultNames);
    }
    return registrants;
    }
    
    public async Task<string> UploadEventRegistrationAsync(dynamic registration)
    {
    ResourceResponse<Document> response = await Client.CreateDocumentAsync(Collection.SelfLink, registration);
    return response.Resource.Id;
    }
    }

3.  **RegistrationContext.cs** 파일을 저장합니다.

#### 검토

이 연습에서는 Azure Cosmos DB에서 문서에 액세스하고 쿼리하는 경우 필요한 C\# 코드를 작성했습니다.

### 연습 5: Azure 저장소에 연결하는 Azure SDK 코드 작성

#### 작업 1: Azure 함수에 대한 블랍 트리거 및 출력 구현

1.  **Contoso.Events.Worker** 프로젝트에 **ProcessDocuments.cs** 를 열립니다.

2.  **Run** 메서드를 찾아 다음 메서드 구현으로 바꿉니다.

<!-- end list -->

    public static async Task Run([BlobTrigger("signinsheets-pending/{name}")] Stream input, string name, [Blob("signinsheets/{name}", FileAccess.Write)] Stream output, TraceWriter log)
    {
    log.Info($"Request received to generate sign-in sheet for event: {name}");
    
    string eventKey = Path.GetFileNameWithoutExtension(name);
    using (MemoryStream stream = await ProcessStorageMessage(eventKey))
    {
    byte[] byteArray = stream.ToArray();
    await output.WriteAsync(byteArray, 0, byteArray.Length);
    }
    
    log.Info($"Request received to generate sign-in sheet for event: {name}");
    }

3.  **ProcessDocuments.cs** 파일을 저장합니다.

#### 작업 2: BlobContext 클래스에서 블랍 업로드 구현

1.  **contoso.Events.Data** 프로젝트에 있는 **BlobContext.cs** 를 엽니다.

2.  **UploadBlobAsync** 메서드를 찾아 다음 메서드 구현으로 바꿉니다.

<!-- end list -->

    public async Task<ICloudBlob> UploadBlobAsync(string blobName, Stream stream)
    {
    CloudStorageAccount account = CloudStorageAccount.Parse(StorageSettings.ConnectionString);
    CloudBlobClient blobClient = account.CreateCloudBlobClient();
    CloudBlobContainer container = blobClient.GetContainerReference($"{StorageSettings.ContainerName}-pending");
    await container.CreateIfNotExistsAsync();
    
    ICloudBlob blob = container.GetBlockBlobReference(blobName);
    stream.Seek(0, SeekOrigin.Begin);
    await blob.UploadFromStreamAsync(stream);
    
    return new DownloadPayload { Stream = stream, ContentType = blob.Properties.ContentType };
    }

3.  **BlobContext.cs** 파일을 **저장합니다**.

#### 검토

이 연습에서는 Azure Function에서 Azure 저장소 블랍을 조작하기 위해 C\# 코드를 작성했습니다.

### 연습 6: 구독 정리 

#### 작업 1: Azure 클라우드 셸 열기

1.  Azure 포털 상단에서 **Cloud Shell** 아이콘을 클릭하여 새 셸 인스턴스를 엽니다. 

2.  포털 하단에 **Cloud Shell** 명령 프롬프트에서 다음 명령을 입력하고 Enter 를 눌러 구독에 모든 리소스 그룹을 나열합니다.

<!-- end list -->

    az group list

3.  다음 명령을 입력하고 Enter 를 눌러 리소스 그룹을 삭제할 수 있는 명령 목록을 봅니다.

<!-- end list -->

    az group delete --help

#### 작업 2: 리소스 그룹 삭제

1.  다음 명령을 입력하고 Enter 를 눌러 **PolyglotData** 리소스 그룹을 삭제합니다.

<!-- end list -->

    az group delete --name PolyglotData --no-wait --yes

2.  포털 하단의 **Cloud Shell** 페인을 닫습니다.

#### 작업 3: 액티브 응용 프로그램 닫기

1.  현재 실행 중인 **Microsoft Edge** 응용 프로그램을 닫습니다.

2.  현재 실행 중인 **Visual Studio Code** 응용 프로그램을 닫습니다.

#### 검토

이 연습에서는 이 랩에 사용된 **리소스 그룹** 을 제거하여 구독을 정리했습니다.
